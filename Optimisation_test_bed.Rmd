---
title: "Optimise sets-e"
author: "Jonathan Bourne"
date: "24/12/2019"
output: html_document
editor_options: 
  chunk_output_type: console
---

Sets-e can be pretty slow. and due to the large amount of iterations it goes through this adds up

What can I do the get speed up improvements?

#setup
Load data. I am going to use provis so I can't load the package version of the function I have to load them direct into the workspace
```{r}
packages <- c("tidyverse", "igraph", "igraphdata", "minpack.lm", "ggraph", "profvis", "microbenchmark", "ggraph", "Matrix")

new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
sapply(packages, library, character.only = TRUE)

basewd <- "/home/jonno/Dropbox/Jonathan_Bourne_Phd_Folder"

list.files(file.path("/home/jonno/Useful_PhD__R_Functions"), pattern = ".R", full.names = T) %>%
  walk(~source(.x))

list.files(file.path("/home/jonno/NetworkSpringEmbedding/R"), pattern = ".R", full.names = T) %>%
  walk(~source(.x))

list.files(file.path("/home/jonno/Setse_optimisation/Alterantive_functions"), pattern = ".R", full.names = T) %>%
  walk(~source(.x))

list.files(file.path("/home/jonno/Setse_optimisation/Original_functions"), pattern = ".R", full.names = T) %>%
  walk(~source(.x))


list.files(file.path("/home/jonno/Setse_optimisation/PowergridNetworking_Original"), pattern = ".R", full.names = T) %>%
  walk(~source(.x))


```


I will use the zachery karate club as an example dataset
```{r}
data("karate", package="igraphdata")

shortest_list <-shortest_paths(karate, from = 1, to = 34, mode = "all" , weights = get.edge.attribute(karate, "weight"), output = "both")

flow_df <- subgraph.edges(karate, shortest_list$epath[[1]]) %>% as_data_frame() %>% 
  mutate(routes = 1) %>% #trying to think how this can be generalised
  group_by(from, to) %>%
  summarise(routes = sum(routes))

karate_edge_df <- as_data_frame(karate) %>%
  mutate(temporary_flow = 1) %>%
  left_join(flow_df) %>%
  mutate(routes = ifelse(is.na(routes), 0, routes),
         edge_name = paste(from, to, sep = "_"))
karate_node_df <- as_data_frame(karate, what = "vertices") %>%
  select(name, everything()) %>%
  mutate(force = case_when(
    name =="Mr Hi" ~1,
    name == "John A" ~-1,
    TRUE ~0
  ))

g <- graph_from_data_frame(karate_edge_df, directed = FALSE, vertices = karate_node_df)  %>%
        set.edge.attribute(. , "distance", value = 1) %>%
        set.edge.attribute(., "Area", value = 1) %>%
        calc_spring_youngs_modulus(., "temporary_flow", "weight", minimum_value = 100, stretch_range = 1000) %>%
        calc_spring_constant(., E ="E", A = "Area", distance = "distance") 

```

#IEEE graph set
the youngs modulus function should be changed so that the attribute it assigns the the network can be nameds.
This is because the youngs modulus is pretty outhtere and who understands it anyway?
```{r}

"UK_high_voltage.rds" 
list.files("/home/jonno/Dropbox/IEEE_Networks/power_grid_graphs")
g2 <- readRDS(file.path("/home/jonno/Dropbox/IEEE_Networks/power_grid_graphs",  "IEEE_300_igraph.rds" ))#"IEEE_118_igraph.rds"))

g3 <- g2 %>% Proportional_Load(., Inf, PowerFlow = "power_flow", Link.Limit = "edge_capacity")

      current_graph  <- g3 %>%
        set.edge.attribute(. , "distance", value = 1) %>%
        set.edge.attribute(., "Area", value = 1) %>%
        calc_spring_youngs_modulus(., "power_flow", "edge_capacity", minimum_value = 10000, stretch_range = 1000) %>%
        calc_spring_constant(., E ="E", A = "Area", distance = "distance") %>%
        normalise_dc_load(.,  
                           generation = "generation", 
                           demand  = "demand",
                           net_generation = "net_generation", 
                           capacity = "edge_capacity",
                           edge_name = "edge_name", 
                           node_name = "name",
                           power_flow = "power_flow")
      g <- current_graph
      
```

#profile function
```{r}

#karate
force = "force"
flow = "routes" 
distance = "distance" 
capacity = "weight"
edge_name = "edge_name"
k = "k"
tstep = 0.2
tol = 10e-14
maxIter = 10000
mass = 1
verbose = FALSE

#IEEE      
force ="net_generation"
flow = "power_flow"
distance = "distance"
capacity = "edge_capacity"
edge_name = "edge_name"
tstep = 0.02
tol = 2/1e3
maxIter = 20000
mass = 1
verbose = FALSE
frctmultiplier = 1.5
coef_drag <- frctmultiplier
sparse = FALSE

#going inside the Find_network_balance function

 Prep <- Prepare_data_for_find_network_balance(g, force, flow, distance, mass, edge_name)
 
 Prep <- Prepare_data_for_find_network_balance2(g, force, flow, distance, mass, edge_name)  

 NodeStatus <- Prep$NodeStatus
 Link <- Prep$Link
 Adjmat <- Prep$Adjmat
 kmat <- Prep$kmat
 dmat <- Prep$dmat
frctmultiplier <-1



time_test_orig_start <- system.time( test_original_algos <-  Find_network_balance2(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                             #  capacity = capacity,
                                               edge_name = edge_name,
                                               tstep = tstep,
                                               tol = tol,
                                               max_iter = 4e4,
                                               mass = mass,
                                             include_edges = TRUE
                                             ))


 time_test_new_start <- system.time(  test_new_algos<-  Find_network_balance3(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                               capacity = capacity,
                                               edge_name = edge_name,
                                               tstep = tstep,
                                               tol = tol,
                                               maxIter = maxIter,
                                               mass = mass,
                                               verbose = FALSE,
                                               frctmultiplier = 0.5))
 
  test_new_algos_1 <-  Find_network_balance3(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                               capacity = capacity,
                                               edge_name = edge_name,
                                               tstep = tstep,
                                               tol = tol,
                                               maxIter = maxIter,
                                               mass = mass,
                                               verbose = FALSE)
  
    profvis(test_new_algos_2 <-  Find_network_balance4(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                               capacity = capacity,
                                               edge_name = edge_name,
                                               tstep = tstep,
                                               tol = tol,
                                               max_iter = maxIter*2,
                                               mass = mass,
                                               verbose = FALSE,
                                               sparse = FALSE,
                                               coef_drag =1.5)
            )
  
    
    profvis(Find_network_balance(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                               capacity = capacity,
                                               edge_name = edge_name,
                                               tstep = tstep,
                                               tol = tol,
                                               maxIter = maxIter,
                                               mass = mass,
                                               verbose = FALSE))
    
    profvis(expr =       Find_network_balance(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                               #capacity = capacity,
                                               edge_name = edge_name,
                                               tstep = tstep,
                                               tol = tol,
                                               max_iter = 15,
                                               mass = mass,
                                              # verbose = FALSE,
                                               sparse = F,
                                             #  frctmultiplier = 5
                                             )
            ,
            interval = 0.005)
    
  all_equal(test_original_algos$NodeList, test_new_algos_1$NodeList)
  all_equal(test_new_algos_1$NodeList, test_new_algos_2$NodeList)
    
  new_NodeList <- test_new_algos$NodeList
  original_NodeList <- test_original_algos$NodeList
  
  test <- test_new_algos_1$NodeList
  test2 <- test_new_algos_2$NodeList
all.equal(test, test2)
  

#The results file for the original and new algos are different on max absolute acceleration. I don't know why
#everything else is the same

bind_rows(test_new_algos$results %>% mutate(type = "new"), 
          test_original_algos$results %>% mutate(type = "original")) %>% as_tibble() %>%
#  filter(t<20) %>%
  ggplot(aes(x = t, y = acceleration, colour = type)) + geom_line()

40*31000/60/24/30

(5/6)*31000/60/24

test <- test_new_algos_2$NodeStatus
tension_strain_embeddings <- calc_tension_strain(g = g,
                                                   test,
                                                   distance = distance, 
                                                   capacity = capacity, 
                                                   flow = flow, 
                                                   edge_name = edge_name, 
                                                   k = "k") %>%
  mutate(potential_energy = 0.5*k*(H-1)^2)

sum(tension_strain_embeddings$potential_energy)

test <- test_new_algos_2$network_dynamics 
test %>%
#  filter(t<500) %>%
  ggplot(aes(x = t, y = log10(static_force+kinetic_force)))+ geom_line()

```


The majority of time is spent in Calc_System_dynamis

```{r}
 profvis(Calc_System_Dynamics(Prep$NodeStatus, Prep$A,  Prep$Link$k, pull(Prep$Link,distance), tstep, 1))


 profvis(microbenchmark(Calc_System_Dynamics(Prep$NodeStatus, Prep$A,  Prep$Link$k, pull(Prep$Link,distance), tstep, 1)), interval = 0.005)

NodeStatus <- Prep$NodeStatus
NodeStatus2 <- Prep$NodeStatus %>% mutate(Delta_acceleration = 0)
kvect <- Prep$Link$k
dvect <- pull(Prep$Link,distance)
EdgeNode <- Prep$A


 microbenchmark(A = Create_Tension_matrix(Prep$A, NodeStatus$z, kvect, dvect),
                B = Calc_Damping_matrix(Prep$A, NodeStatus$velocity, kvect, NodeStatus$mass))
```


#test the time step
```{r}



tstep_test <- {seq(0.02, 0.045, by = 0.005  )} %>% #0.02%>%# 
  map_df(~{
    print(.x)
   res <- Find_network_balance(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                               capacity = capacity,
                                               edge_name = edge_name,
                                               tstep = .x,
                                               tol = tol,
                                               maxIter = 1000,
                                               mass = mass,
                                               verbose = FALSE)
    
 Out <-  res$network_dynamics %>% mutate(tstep = .x)
 return(Out) 
 }) %>%
  group_by(tstep) %>%
  mutate(t_norm = t/max(t, na.rm = T)) %>%
  ungroup %>%
  filter(complete.cases(.))

tstep_test %>%
#filter(tstep <0.02) %>%
  filter(
    t_norm>0.0, t_norm<1.0, 
    #     strain>0.0888
    ) %>%
ggplot(aes(x = t_norm, y =strain, colour = as.factor(tstep))) + geom_line()


tstep_test %>%
filter(tstep ==0.045) %>%
ggplot(aes(x = log10(force_energy), y = log10(kinetic_energy), colour = as.factor(tstep))) + geom_point()

tstep_test %>%
filter(tstep ==0.045) %>%
ggplot(aes(x = log10(force_energy), y = log10(kinetic_energy), colour = t_norm)) + geom_point() +scale_colour_viridis_c()

tstep_test %>%
filter(tstep ==0.045) %>%
ggplot(aes(x = (t_norm), y =log10(strain), colour = t_norm)) + geom_line() +scale_colour_viridis_c()

test <- tstep_test %>%
  filter(tstep == 0.02)


test_number_of_iters <- Find_network_balance3(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                               capacity = capacity,
                                               edge_name = edge_name,
                                               tstep = 0.02,
                                               tol = tol,
                                               maxIter = 40000,
                                               mass = mass,
                                               verbose = FALSE)

test_number_of_iters$results %>%
  filter(t>20000)

tstep_test_val <- 0.02
test_dat <- calculate_SET2(g, 
                           force =force,
                           flow = flow,
                           distance = distance,
                           capacity = capacity,
                           edge_name = edge_name,
                           k = "k",
                           tstep = tstep_test_val,
                           tol,
                           maxIter = 1000,
                           mass = 1,
                           verbose = FALSE)

test_new_package <- SETS_embedding(g, 
                           force =force,
                           flow = flow,
                           distance = distance,
                           capacity = capacity,
                           edge_name = edge_name,
                           k = "k",
                           tstep = tstep_test_val,
                           tol,
                           maxIter = 1000,
                           mass = 1,
                           verbose = FALSE)


all_equal(test_dat$network_dynamics, test_new_package$network_dynamics)

test_dat_inf <- test_dat$edge_embeddings

test <- bind_rows(test_dat$network_dynamics %>% mutate(type = "articulation", 
                                                       t_norm = t/tstep_test_val) ,
                  test_number_of_iters$network_dynamics %>% mutate(type = "whole network",
                                                                   t_norm = t/0.02))

test%>%
  filter(t_norm > 39000) %>%
  ggplot(aes(x = t_norm, y = log10(force_energy), colour = type))+ geom_line()


test%>%
  ggplot(aes(x = t, y = value, colour = name))+ geom_line()
  
  
test <-  test_dat$node_embeddings %>% left_join(test_number_of_iters$NodeStatus %>% select(node, z2 = z)) %>%
    mutate(dz = (z-mean(z))-(z2- mean(z2)),
           dz_perc = dz/z) 
ggplot(test, aes(x = dz)) + geom_density()

bind_rows(test_dat$node_embeddings %>% mutate(type = "articulation"), test_number_of_iters$NodeStatus %>%
            mutate(type = "whole network")) %>%
  group_by(type) %>%
  mutate(z_norm = z - mean(z))%>%
  ggplot(aes( x= percent_rank(z_norm), y = z_norm, colour = type)) + geom_point()


```


#Comparing old and new Algos
This is to compare 40k iterations using the original algos and the new ones. I want to see what the time and stability difference is.

What I see is that the original algo wasn't run long enough to converge properly. This is probably partly due to the error in the distance formula. As a result the new algo is several orders of magnitude more stable than the previous algo, as well as being about 1.5 orders of magnitude faster.

I can half the number of iterations and still be 1000 times more stable

```{r}

iters_comp <- 40000
Prep <- Prepare_data_for_find_network_balance(g, force, flow, distance, mass, edge_name)

#Overwrite the functions with the original functions
list.files(file.path("/home/jonno/Setse_optimisation/Original_functions"), pattern = ".R", full.names = T) %>%
  walk(~source(.x))

original_time <- system.time(original_algo <- calculate_SET(g, force,
                                                            flow,
                                                            distance,
                                                            capacity,
                                                            k = "k",
                                                            tstep = 0.005,
                                                            tol = 10e-14,
                                                            maxIter = iters_comp))

#Overwrite with new functions
list.files(file.path("/home/jonno/NetworkSpringEmbedding/R"), pattern = ".R", full.names = T) %>%
  walk(~source(.x))


new_time <-system.time( new_algo <- FindStabilSystem(
  g = g,
  distance = distance,
  NodeStatus = Prep$NodeStatus, 
  Adjmat = Prep$Adjmat, 
  flow = flow,
  kmat = Prep$kmat, 
  dmat = Prep$dmat,
  capacity = capacity,
  edge_name = edge_name,
  tstep = 0.02, 
  maxIter = iters_comp, 
  frctmultiplier = frctmultiplier, 
  sparse = FALSE,
  tol = tol, 
  verbose = verbose) )

bicomp_time <- system.time(bicomp_algo <- SETS_embedding(g, 
                                                         force =force,
                                                         flow = flow,
                                                         distance = distance,
                                                         edge_name = edge_name,
                                                         capacity = "edge_capacity",
                                                         k = "k",
                                                         tstep = 0.002,
                                                         tol = 0,
                                                         max_iter = 40000,
                                                         mass = 1,
                                                         verbose = FALSE))

combined_results  <-bind_rows(
  original_algo$node_embeddings %>% mutate(type = "original"),
  bicomp_algo$node_embeddings %>% mutate(type = "bicomp"),
                 new_algo$NodeStatus %>% mutate(type = "new")) %>%
  mutate(kinetic_energy = 0.5*mass*velocity^2) %>%
  group_by(type) %>%
  mutate(z_norm = z-mean(z)) %>%
  ungroup(z)


combined_summary <-combined_results %>%
  group_by(type) %>%
  summarise(kinetic_energy = sum(kinetic_energy),
          force_energy = sum(abs(NetForce + friction))) %>%
  mutate(relative_energy =(force_energy+kinetic_energy)/2) #the normalised initial energy persecond is 2
  

combined_summary  %>%
  ggplot(aes(x = log10(kinetic_energy), y = log10(force_energy), colour = type)) +geom_point()

#They are all eseentially the same
combined_results %>%
  #filter(type !="new") %>%
  ggplot(aes(x = node, y = log10(z_norm-min(z_norm)), colour = type)) +geom_point()


  Prep_new <- Prepare_data_for_find_network_balance3(g = g, 
                                                 force = force, 
                                                 flow = flow, 
                                                 distance = distance, 
                                                 mass = mass, 
                                                 edge_name = edge_name,
                                                 sparse = sparse)
  
  profvis(Find_network_balance4(g = g,
                                force =force,
                                flow = flow,
                                distance = distance,
                                capacity = capacity,
                                edge_name = edge_name,
                                tstep = tstep,
                                tol = tol,
                                max_iter = 20000,
                                mass = mass,
                                verbose = FALSE,
                                sparse = FALSE,
                                coef_drag =1.5)
  )
  
test <-bicomp_algo$node_embeddings %>%
  mutate(friction_fract = abs(friction)/abs(force +NetTension))
test <- bicomp_algo$network_dynamics
test %>%
  filter(force_energy<5) %>%
  ggplot(aes(x = t, y = (force_energy+kinetic_energy))) + geom_line()

```


#epoch of convergence


There may be something in creating epochs.
However, It is complicated and the stability of the models is very good now anyway so I don't think it is necessary right now to explore.
The models can be run with a larger timstep and for less iterations. This makes convergence faster on two counts.
It may be that having some method of automatically choosing the timestep will make convergence more adaptable and provide order of magnitude stability increases.

Mass also influences convergence rate and probability of divergence


Convergence seems to follow three phases. The first phase observed in log space is not a lot happening with regards static force. 
```{r}

#Overwrite with new functions
list.files(file.path("/home/jonno/NetworkSpringEmbedding/R"), pattern = ".R", full.names = T) %>%
  walk(~source(.x))

max_iter <- 2000
tstep <- 0.02
coef_drag <- 1.5
mass <- 1
profvis(    base_case <-  Find_network_balance(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                               #capacity = capacity,
                                               edge_name = edge_name,
                                               tstep = tstep,
                                               tol = tol,
                                               max_iter = max_iter*11,
                                               mass = mass,
                                               verbose = FALSE,
                                               sparse = FALSE,
                                               coef_drag =coef_drag),
            interval = 0.005)
    
     base_case$network_dynamics   %>% mutate(tstep = 0.02, epoch = 0) %>%
  mutate(t_norm = t/tstep,
         Iter2 = Iter+((epoch)*(max_iter-1))) %>%
# filter(Iter2<1100) %>%
ggplot(aes(x = log10(Iter2), y =log10(potential_energy), colour = as.factor(tstep))) + geom_line()

Start <- Find_network_balance(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                             # capacity = capacity,
                                               edge_name = edge_name,
                                               tstep = tstep,
                                               tol = tol,
                                               max_iter = max_iter,
                                               mass = mass,
                                               verbose = FALSE,
                                               sparse = FALSE,
                                               coef_drag =coef_drag)


epoch <- tibble(epoch = 1:10,tstep = 0.02)
                *(1.05^(1:10)))# tstep = 0.045+ (0.01*epoch)) #tstep = 0.045*(2^log(1:10)

total_dynamics <-  Start$network_dynamics %>% mutate(tstep = 0.02, epoch = 0)

  Prep <- Prepare_data_for_find_network_balance(g = g, 
                                                 force = force, 
                                                 flow = flow, 
                                                 distance = distance, 
                                                 mass = mass, 
                                                 edge_name = edge_name,
                                                 sparse = FALSE)
  NodeList <- Start$node_status
profvis(for(i in 1:100){

  Out <- FindStabilSystem(
    node_status = NodeList, 
    ten_mat = Prep$ten_mat, 
    non_empty_matrix = Prep$non_empty_matrix, 
    kvect = Prep$kvect, 
    dvect = Prep$dvect, 
    mass = mass,
    tstep = epoch$tstep[i], 
    max_iter = max_iter, 
    coef_drag = coef_drag,
    tol = tol, 
    verbose = FALSE,
    sparse = FALSE) 

NodeList <- Out$node_status

total_dynamics <- bind_rows(total_dynamics, Out$network_dynamics %>% mutate(tstep = epoch$tstep[i], epoch = epoch$epoch[i]))

}
)
 total_dynamics  %>% group_by(tstep) %>%
  mutate(t_norm = t/tstep,
         Iter2 = Iter+((epoch)*(max_iter-1))) %>%
# filter(Iter2>18000, Iter2<18100) %>%
ggplot(aes(x = log10(Iter2), y =log10(potential_energy), colour = as.factor(tstep))) + geom_line()

total_dynamics %>%
ggplot(aes(x = log10(static_force), y = log10(kinetic_force), colour = as.factor(tstep))) + geom_line()



NodeList_static <- Start$node_status
total_dynamics_static <-  Start$network_dynamics %>% mutate(tstep = tstep, epoch = 0)

for(i in 1:10){
    
 Out <- FindStabilSystem(
    node_status = NodeList_static %>% mutate(velocity = 0, friction = 0, net_force = net_tension, acceleration = net_force/mass), 
    ten_mat = Prep$ten_mat, 
    non_empty_matrix = Prep$non_empty_matrix, 
    kvect = Prep$kvect, 
    dvect = Prep$dvect, 
    mass = mass,
    tstep = epoch$tstep[i], 
    max_iter = max_iter, 
    coef_drag =coef_drag,
    tol = tol, 
    verbose = FALSE,
    sparse = FALSE) 

NodeList_static <- Out$node_status

total_dynamics_static <- bind_rows(total_dynamics_static, Out$network_dynamics %>% mutate(tstep = epoch$tstep[i], epoch = epoch$epoch[i]))

}

test_static<- total_dynamics_static  %>% group_by(tstep) %>%
  mutate(t_norm = t/tstep,
         Iter2 = Iter+(epoch*(max_iter-1))) 

test_static %>%
# filter(tstep<0.045) %>%
ggplot(aes(x = Iter2, y =log10(static_force), colour = as.factor(tstep))) + geom_line()


bicomp <- SETS_embedding(g, 
                         force =force,
                         flow = flow,
                         distance = distance,
                         capacity = capacity,
                         edge_name = edge_name,
                         k = "k",
                         tstep = tstep,
                         tol,
                         max_iter = max_iter*11,
                         coef_drag = coef_drag,
                         mass = mass#,
                        # verbose = FALSE
                         )


all_res <- bind_rows(base_case$network_dynamics %>% mutate(tstep = tstep, epoch = 0, type = "base"),
          total_dynamics %>% mutate(type = "dynamic"),
          total_dynamics_static %>% mutate(type = "static"),
          bicomp$network_dynamics %>% mutate(tstep = tstep, epoch = 0, type = "bicomp")
          )

all_static <- all_res   %>%
  mutate(t_norm = t/tstep,
         Iter2 = Iter+(epoch*(max_iter-1))) 

all_static %>%
ggplot(aes(x = log10(Iter2), y =log10(static_force), colour = as.factor(type))) + geom_line()

all_static %>%
  filter(type !="static") %>%
ggplot(aes(x = log10(Iter2), y =log10(potential_energy), colour = as.factor(tstep), group = type)) + geom_line()+
  facet_grid(~type)

```

#expanded
```{r}

df <- tibble(x = c("a", "b"), n = c(1, 2))

df %>%
  slice(rep(1:n(), 4))


compare_expanded <- c(1, Inf) %>% map_df(~{
  pl_load_val <-.x
  expanded_test_drag <- 3
  expanded_test_tstep <-0.05
  expanded_test_tol <-0.0
  expanded_test_iter <- 20000*4
    
  
  expanded_graph <- readRDS(file.path("/home/jonno/Dropbox/IEEE_Networks/power_grid_graphs", "IEEE_118_igraph.rds" )) %>%
    Proportional_Load(., pl_load_val, PowerFlow = "power_flow", Link.Limit = "edge_capacity")
  
  expanded_graph  <- expanded_graph %>%
    set.edge.attribute(. , "distance", value = 1) %>%
    set.edge.attribute(., "Area", value = 1) %>%
    calc_spring_youngs_modulus(., "power_flow", "edge_capacity", minimum_value = 100, stretch_range = 100) %>%
    calc_spring_constant(., E ="E", A = "Area", distance = "distance") %>%
    normalise_dc_load(.,  
                      generation = "generation", 
                      demand  = "demand",
                      net_generation = "net_generation", 
                      capacity = "edge_capacity",
                      edge_name = "edge_name", 
                      node_name = "name",
                      power_flow = "power_flow")
  
  
  full_run <-Find_network_balance_expanded(g = expanded_graph,
                                           force =force,
                                           flow = flow,
                                           distance = distance,
                                           edge_name = edge_name,
                                           tstep = expanded_test_tstep,
                                           tol = expanded_test_tol,
                                           max_iter = expanded_test_iter,
                                           mass = mass,
                                         #  verbose = FALSE,
                                           sparse = FALSE,
                                           coef_drag =expanded_test_drag)
  
  normal_run <-Find_network_balance(g = expanded_graph,
                                    force =force,
                                    flow = flow,
                                    distance = distance,
                                    edge_name = edge_name,
                                    tstep = expanded_test_tstep,
                                    tol = expanded_test_tol,
                                    max_iter =expanded_test_iter,
                                    mass = mass,
                                  #  verbose = FALSE,
                                    sparse = FALSE,
                                    coef_drag =expanded_test_drag)
  
  
  expanded_bicomp_converge <- SETS_embedding_expanded(g= expanded_graph, 
                                                      force =force,
                                                      flow = flow,
                                                      distance = distance,
                                                      edge_name = edge_name,
                                                      k = "k",
                                                      tstep = expanded_test_tstep,
                                                      tol = expanded_test_tol,
                                                      max_iter = expanded_test_iter ,
                                                      coef_drag = expanded_test_drag,
                                                      mass = mass
  )
  
  dynamics <- normal_run$network_dynamics
  print("calculating dynamics for expanded bicomp")
  
  dynamics_bicomp <- expanded_bicomp_converge %>%
    group_by(Iter) %>%
    summarise(
              static_force = sum(abs(static_force)),  #static force. The force exerted on the node
              kinetic_force = sum(abs(0.5*mass*velocity/tstep)), #kinetic_force 
              potential_energy =1, #sum( 0.5*kvect*(Hvect-dvect)^2),     #spring potential_energy, calculating at end is a nightmare
              kinetic_energy = sum(0.5*mass*velocity^2) ) %>%
    mutate(t = Iter*tstep)
  
  #final node elevation

final_state <- full_run %>%
  filter(t == max(t))

bicomp_final_state <- expanded_bicomp_converge %>%
  filter(t == max(t))
  
  full_run_comp <- full_run %>%
    left_join(., final_state %>% select(node, final_elevation = elevation)) %>%
    mutate(APE = abs((elevation-final_elevation)/elevation)) %>%
    mutate(t = round(t,5)) %>%
    group_by(t) %>%
    summarise(MAPE = mean(APE)) %>%
    left_join(dynamics %>% mutate(t = round(t,5)) ) %>%
    mutate(ec = pl_load_val,
           type = "simple")
  
    bicomp_comp <- expanded_bicomp_converge %>%
    left_join(., bicomp_final_state %>% select(node, final_elevation = elevation)) %>%
    mutate(APE = abs((elevation-final_elevation)/elevation)) %>%
    mutate(t = round(t,5)) %>%
    group_by(t) %>%
    summarise(MAPE = mean(APE)) %>%
    left_join(dynamics_bicomp %>% mutate(t = round(t,5)) ) %>%
    mutate(ec = pl_load_val,
           type = "bicomp")
  
  
    
  Out <- bind_rows(full_run_comp, bicomp_comp )
  
  return(Out)
}
)


#The error spikes get compressed as ec goes to infinty
compare_expanded  %>%
   filter((round(t/tstep)%%100)==0) %>%
  filter(is.finite(MAPE))%>%
 # filter(ec == 1) %>%
  ggplot(aes(x = (Iter), y = log10(MAPE), colour = factor(ec), group = interaction(ec, type))) + geom_line()+
  geom_hline(yintercept = -3)+
  ggtitle("tstep 0.02 coef drag 3 k 10k c 10k ")


compare_expanded  %>%
   filter((round(t/tstep)%%100)==0) %>%
  filter(is.finite(MAPE))%>%
#  filter(Iter>5000) %>%
  #filter(type =="bicomp") %>%
  ggplot(aes(x = log10(static_force/2), y = log10(MAPE), colour = factor(ec), group = interaction(ec, type))) + geom_line()+
  geom_hline(yintercept = -3) #+
  #facet_grid(~type)

#
compare_expanded  %>%
filter((round(t/tstep)%%100)==0) %>%
  filter(is.finite(MAPE)) %>%
  ggplot(aes(x = (Iter), y = log10(MAPE), colour = log10(static_force))) + geom_point()+
  scale_color_viridis_c()
 
#The static force reduces log linearly for all values between 0 and infintiy, after the initial elbow.
#The angle of linear regression appears to be logistic between o and infinity. possibly a tan relationship
compare_expanded %>%
  filter((round(t/tstep)%%100)==0) %>%
  filter(is.finite(MAPE)) %>%
  ggplot(aes(x = Iter, y = log10(static_force), colour = factor(ec))) + geom_line() +
  geom_hline(yintercept = -4)

#Although the final position of the nodes takes a lot of time the final energy state of the network is quickly found
#Low levels of k have more energy and infinite k has the least energy
compare_expanded %>%
    filter((round(t/tstep)%%100)==0) %>%
  filter(is.finite(MAPE)) %>%
  ggplot(aes(x = log10(Iter), y = log10(potential_energy), colour = factor(ec))) + geom_line()

  #All values have the same log log linear relationship between static force and kinetic energy
compare_expanded %>%
      filter((round(t/tstep)%%100)==0) %>%
  filter(is.finite(MAPE)) %>%
  ggplot(aes(x = log10(static_force), y = log10(kinetic_energy), 
             colour = factor(ec)#log10(Iter)
             )) + geom_line()

```


expanded bi connected version
```{r}
list.files(file.path(basewd, "NetworkSpringEmbedding/R"), pattern = ".R", full.names = T) %>%
  walk(~source(.x))
max_iter = 200
#compare_expanded <- c(1, 1.5, Inf) %>% map_df(~{
  pl_load_val <-3#.x
  expanded_test_drag <- 3.5
  expanded_test_tstep <-0.02
  expanded_test_tol <-0.0
  expanded_test_iter <- 20000*6
  
  expanded_graph <- readRDS(file.path("/home/jonno/Dropbox/IEEE_Networks/power_grid_graphs", "IEEE_118_igraph.rds" )) %>%
    Proportional_Load(., pl_load_val, PowerFlow = "power_flow", Link.Limit = "edge_capacity")
  
  expanded_graph  <- expanded_graph %>%
    set.edge.attribute(. , "distance", value = 1) %>%
    set.edge.attribute(., "Area", value = 1) %>%
    calc_spring_youngs_modulus(., "power_flow", "edge_capacity", minimum_value = 100, stretch_range = 100) %>%
    calc_spring_constant(., E ="E", A = "Area", distance = "distance") %>%
    normalise_dc_load(.,  
                      generation = "generation", 
                      demand  = "demand",
                      net_generation = "net_generation", 
                      capacity = "edge_capacity",
                      edge_name = "edge_name", 
                      node_name = "name",
                      power_flow = "power_flow")
  
  g <- expanded_graph
  
```


#NEW fix_z_to_origin function
the current fix z function doesn't work well if you expand the convergence.
I also don't understand what it does.
I want re-write the function so that it is more intuitive.
Re-writing the function is extremly hard
```{r}
list.files(file.path("/home/jonno/NetworkSpringEmbedding/R"), pattern = ".R", full.names = T) %>%
  walk(~source(.x))
OriginBlock <- Find_network_balance_expanded(List_of_BiConComps[[11]],
                                  force =force, 
                                  flow = flow, 
                                  tstep = tstep, 
                                  coef_drag = coef_drag,
                                  tol = tol, 
                                  distance = distance, 
                                  edge_name = edge_name,
                                  max_iter =  max_iter, 
                                  mass =  mass, 
                                  sparse = sparse,
                                  verbose = verbose)

#The origin block is the largest connected component

  List_of_BiConComps <- create_balanced_blocks(g, 
                                               force = force, 
                                               flow = flow)
  
  #find the largest component and use that as the origin block
  OriginBlock_number <-List_of_BiConComps %>% map_dbl(~vcount(.x)) %>% which.max()

biconnected_g_info <- biconnected.components(g)

#the articulations nodes and their graph vertex ids
articulation_nodes_df <-tibble(name = names(biconnected_g_info$articulation_points), id = biconnected_g_info$articulation_points)

##get the first node that is NOT an articulation point
#This is done my numbering all the nodes from 1 to the total nodes in the component. then finding the names of the node in the origin block
#that are also biconnected components. These nodes are removed and the the node with the smallest ID is the origin point from which
#distances and shortes paths will be measured.
origin_block_base_node_name <-get.vertex.attribute(g,"name")[-which(get.vertex.attribute(List_of_BiConComps[[OriginBlock_number]],"name") %in% articulation_nodes_df$name)] %>% 
  min

#The distance from the base node is calculated here in a named vector,
distance_from_origin <- distances(g)[articulation_nodes_df$id, origin_block_base_node_name]

#articulation nodes in each component are found here by looping through each 
#component and seeing which of the articulation nodes are present
node_bicomp_relation <- 1:length(biconnected_g_info$components) %>% 
  map_df(~{
  
    articulation_nodes_df %>%
      filter(id %in% biconnected_g_info$components[[.x]]) %>%
      mutate(component = .x)
      
  
}) %>%
  left_join(., tibble(name = names(distance_from_origin), distance = distance_from_origin), by = "name") %>%#add in distance from origin data
             group_by(component) %>%
  mutate(is_floor = (min(distance)== distance) & OriginBlock_number != component ) %>% #mark the node that is closest to the origin in each component
  ungroup

#Using the shortest path from the origin node to the articulation point find all the floor and ceiling nodes
#for a given destination point each component has a pair of articulations points
#one is the floor the other is the ceiling.
#the floor node is the node that is closest to the origin the ceiling is the node that is furthest away.

#calculates the shortest path for every floor node in each component
#As the components are bi-components are bi-connected and the distance is from a single point
#components can only have a single and unique floor node. However, that floor node
#can be the floor node of multiple components
bicomp_shortest_paths <- shortest_paths(g, 
                       from = origin_block_base_node_name, 
                       to = unique(node_bicomp_relation$name[node_bicomp_relation$is_floor]),
                       output = "both")

#Which compenents are on the shortest path of the component being checked component being checked?
#This is important as a node can be a floor for multiple components. We don't want to re-level for all the components
#the node is part of. We only want components for which there are two nodes on the shortest path as well as the terminating 
#node becuase that is in the final component

#This requires another loop. which checks to see if the component is part of the shortest path route for the nodes

floor_df_2<- ceiling_df_2 <- node_bicomp_relation  %>%
  mutate(path_component = NA,
         path_component2 = NA,
         target_node_name = NA) %>% slice(0)

for(i in 1:length(bicomp_shortest_paths$vpath) ){
  target_shortest_path <-i
  
  component_specific_floor_ceiling_nodes <- bicomp_shortest_paths$vpath[[target_shortest_path]]
  node_path <- bicomp_shortest_paths$vpath[[target_shortest_path]]
  edge_path <- bicomp_shortest_paths$epath[[target_shortest_path]] #this may not be necessary and then output can be "vpath" only
  
  component_specific_floor_ceiling_nodes_2 <- names(bicomp_shortest_paths$vpath[[target_shortest_path]])[-1]
  
  template_nodes_df <-node_bicomp_relation %>%
    ungroup() %>%
    group_by(component) %>%
    mutate(path_component = (name %in% component_specific_floor_ceiling_nodes_2)*1,
           path_component2 = sum(path_component)) %>%
    ungroup %>%
    mutate(target_node_name = names(node_path[length(node_path)]))
  
  floor_df <- template_nodes_df  %>%
    filter(path_component==1, #the node has to be on the shortest path
           (path_component2>1 | #And the component the node is in needs to have a floor and ceiling
              id == target_node_name) & # or be the target node
             is_floor)#and all the nodes need to be floors
  
  #This finds the ceilings using the floor dataframe to subset the data
  ceiling_df <- template_nodes_df %>%
    filter((component %in% floor_df$component) | #The component has to be one of the components that contains a floor
             component ==OriginBlock_number, #or it has to be the origin block component
           id %in% floor_df$id, #And the node id has to be a node that is also a floor
           !is_floor) #But the node cannot be in a component where it is actually a floor
  
  floor_df_2 <- bind_rows(floor_df_2, floor_df)
  ceiling_df_2 <- bind_rows(ceiling_df_2, ceiling_df)
  }

#these two peieces of code create the data frames that provide the references for all
ceiling_df <- node_bicomp_relation %>%
 left_join(ceiling_df_2 %>% select(ref_node = name, ref_component = component, name = target_node_name) , by = "name") %>%
  filter(component !=  OriginBlock_number) %>%
  distinct(component, ref_node, ref_component) %>%
  make_interaction_matrix(.)

floor_df <- node_bicomp_relation %>%
 left_join(floor_df_2 %>% select(ref_node = name, ref_component = component, name = target_node_name) , by = "name") %>%
  filter(component !=  OriginBlock_number) %>%
  distinct(component, ref_node, ref_component) %>%
  make_interaction_matrix(.)


test2 <- as.matrix(floor_df)
#This function creates the interaction matrix between nodes in each component.
#It does this by creating a meta graph where nodes a component-node pairs and links mean a node is the floor or ceiling of another another node. It is effectively a directed matrix but is modelled as undirected
make_interaction_matrix <- function(target_df){
#the edges in the meta graph, these are only the articulation nodes
active_edges <- relative_blocks %>%
  filter(Iter == max(Iter)) %>%
  left_join(., target_df, by = "component") %>%
  mutate(active_reference = 1) %>%
  filter(complete.cases(.)) %>%
  mutate(node_comp_rows = paste(node, component, sep ="-"),
         node_comp_columns = paste(ref_node, ref_component, sep ="-")) %>%
  select(node_comp_rows, node_comp_columns, active_reference) %>%
  select(1:2)#remove missing these occur in the terminating components

#the nodes in the meta graph, this is all the node/component relationships
non_active_edges <- relative_blocks %>%
  filter(Iter == max(Iter)) %>%
  mutate(ref_node = node,
         ref_component = component,
         active_reference = 0) %>%
  mutate(node_comp_rows = paste(node, component, sep ="-"),
         node_comp_columns = paste(ref_node, ref_component, sep ="-")) %>%
  arrange(node) %>%
  select(node_comp_rows, node_comp_columns, active_reference) %>%
  select(1:2)

#The sparse matrix of the  floor/ceiling interaction
sparse_matrix_result <- graph_from_data_frame(node_component_pairs,
                                              directed = T,
                                              vertices = non_active_edges) %>%
  as_adjacency_matrix() 

return(sparse_matrix_result)
}

block_diag_floor <- bdiag(lapply(1:(max_iter+1), function(n){floor_df}))
block_diag_ceiling <- bdiag(lapply(1:(max_iter+1), function(n){ceiling_df}))

adjust_elevation <- as.vector(block_diag_ceiling %*% relative_blocks$elevation) + as.vector(block_diag_floor %*% relative_blocks$elevation)
adjust_velocity <- as.vector(block_diag_ceiling %*% relative_blocks$velocity) + as.vector(block_diag_floor %*% relative_blocks$velocity)
  


g2 <- set.vertex.attribute(g, name = "color", value = NA)  %>% 
 # set.vertex.attribute(., name = "floor", index =  floor_df$id, value = "is_floor") %>%
  set.edge.attribute(., name = "color", index = edge_path, value = "red") %>%
  set.edge.attribute(., name = "target_comp", index =  edge_path, "target")
set.seed(158)
ggraph(g2, layout = layout_with_fr(g)) +
   geom_edge_link2(aes(color = target_comp), width = 0.7) +
  scale_edge_colour_discrete() +
  geom_node_point( aes(color = color ),
                   size = 2.5) +
  labs(edge_colour = "shortest path", shape = "Node type", "") +
  ggtitle("IEEE 118 power grid with Fruchtman Reingold projection")


tstep <- 0.02
coef_drag <- 1.5


profvis(plain_converge <- Find_network_balance(g, 
                         force =force,
                         flow = flow,
                         distance = distance,
                         edge_name = edge_name,
                         tstep = tstep,
                         tol = 0,
                         max_iter = 12e4,
                         coef_drag = coef_drag,
                         mass = mass,
                         sample = 100
                         ))

plain_converge_expanded <- Find_network_balance_expanded(g, 
                         force =force,
                         flow = flow,
                         distance = distance,
                         edge_name = edge_name,
                         tstep = tstep,
                         tol = 0,
                         max_iter = 6e4,
                         coef_drag = coef_drag,
                         mass = mass
                         )

profvis(plain_bicomp_converge <- SETS_embedding(g, 
                                        force =force,
                                        flow = flow,
                                        distance = distance,
                                        capacity = capacity,
                                        edge_name = edge_name,
                                        k = "k",
                                        tstep = tstep,
                                        tol = 0,
                                        max_iter = 12e4,
                                        coef_drag = coef_drag,
                                        mass = mass,
                                        sample = 100
))

test <- plain_bicomp_converge$node_embeddings 

test2 <- bind_cols(plain_converge$node_status %>% 
                     select(elev_truth = elevation,
                            static_force_truth = static_force), 
                   test %>% 
                     select(elev_est = elevation,
                            static_force_est = static_force))
metrics(test2, truth = elev_truth, estimate = elev_est)
metrics(test2, truth = static_force_truth, estimate = static_force_est)

expanded_bicomp_converge <- SETS_embedding_expanded(g, 
                         force =force,
                         flow = flow,
                         distance = distance,
                         edge_name = edge_name,
                         k = "k",
                         tstep = tstep,
                         tol = 0,
                         max_iter = 1e5 ,
                         coef_drag = coef_drag,
                         mass = mass#,
                        # verbose = FALSE
                         )




final_iter <- expanded_bicomp_converge %>%
  filter(Iter == max(Iter)) %>%
  mutate(elevation = elevation - mean(elevation)) %>%
  select(-Iter)
  

calc_tension_strain()

plain_node_bicomp <-plain_bicomp_converge$node_embeddings %>%
  rename(component = Reference_ID) %>% select(-component)

plain_node <-plain_converge$node_status

test <- left_join(
  plain_converge$node_status %>% select(node, elevation),
 # plain_node_bicomp %>% select(node, elevation_bicomp = elevation), 
) %>%
  left_join(.,   final_iter  %>% select(node,  elevation_adjust = elevation)) %>%
  mutate_if(., is.numeric, function(n){n-mean(n)})



all_edges <-1:3 %>% map_df(~{
  
  calc_tension_strain(g, list(simple = plain_converge$node_status,
                              bicomp = plain_bicomp_converge$node_embeddings,
                              test = expanded_bicomp_converge %>% filter(Iter ==max(Iter)))[[.x]], "distance",
                    capacity = "edge_capacity") %>%
    mutate(type = c("simple", "bicomp", "test")[.x])
  })

test %>%
  pivot_longer(., cols = elevation:elevation_adjust, names_to = "type", values_to = "elevation") %>%
  group_by(type) %>%
  mutate(norm_elev = elevation - mean(elevation)) %>%
  ggplot(aes(x = node, y = norm_elev, colour = type)) + geom_jitter()


bind_rows(plain_converge_expanded %>% mutate(type = "plain"),
          expanded_bicomp_converge %>% mutate(type = "bicomp")) %>%
  filter((Iter %% 100)==0) %>%
  filter(#node %in% LETTERS[4:5],
         Iter <5000)  %>%
  group_by(Iter, type) %>%
  mutate(elevation_norm = elevation-mean(elevation)) %>%
  ggplot(aes(x = (Iter), y = elevation_norm, colour = type, group = interaction(type, node))) + geom_line()
  

```


#comparison of two models
```{r}
profvis(    base_case <-  Find_network_balance(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                               edge_name = edge_name,
                                               tstep = tstep,
                                               tol = tol,
                                               max_iter = 4e4,
                                               mass = mass,
                                               sparse = FALSE,
                                               coef_drag =coef_drag),
            interval = 0.005)


  
 #FindStabilSystem_test <-compiler::cmpfun(FindStabilSystem_test)
  
profvis(    test_case <-  Find_network_balance4(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                               edge_name = edge_name,
                                               tstep = tstep,
                                               tol = tol,
                                               max_iter = 4e4,
                                               mass = mass,
                                               sparse = FALSE,
                                               coef_drag =coef_drag),
            interval = 0.005)


all.equal(base_case$node_status, test_case$node_status)

test1 <- base_case$node_status
test2 <-  test_case$node_status

class(test_case$node_status$elevation)
```

#C++ Armadillo

Here I try to implement the find_stabil_system algo in C++ to make the loop super fast and hopefully better memory management
```{r}


Rcpp::cppFunction(depends = "RcppArmadillo", code = '
Rcpp::List FindStabilSystemCpp(
const arma::mat &node_status, 
const arma::mat &ten_mat, 
const arma::mat &non_empty_matrix, 
const arma::vec &kvect, 
const arma::vec &dvect, 
const double mass,
const double tstep, 
const int max_iter = 1000, 
const double coef_drag = 1,
const double tol = 1e-10) {
//#Ideally the columns of this matrix would be named but it isnot essential and they can be named later
arma::mat network_dynamics = arma::mat(max_iter, 6).fill(NA_REAL);

//#create vectors from the non empty indexing matrix. this is for ease of use in the function
  arma::vec edge_index =  vectorise(non_empty_matrix.col(1));
arma::vec edge_index_t = vectorise(non_empty_matrix.col(2));
arma::vec edge_mat_index = vectorise(non_empty_matrix.col(3));


  int Iter = 1;
  bool system_stable = FALSE;

while((Iter <= max_iter) && !system_stable )
{
  
  //#It overwirtes the preious values but doesnt create anything else
    arma::mat  NodeList2 = NodeList;
  //
  //create the tension matrix;
  //
    //#dz is the change in eleveation    
    arma::vec dvect = vectorise(NodeList.submat(edge_index_t, 2)) -  vectorise(NodeList.submat(edge_index, 2));    
  //#the hypotenuse of the spring distance triangle
    arma::mat Hvect = sqrt(dzvect^2 + dvect^2);
  //#the tension vector. the dZvect/Hvect is the vertical component of the tension
    ten_mat.elem(edge_mat_index) = kvect * (Hvect - dvect) * dzvect / Hvect;
  
       NodeList2(,3) = sum(ten_mat, 1); //#sum the rows. It may be faster to change the ten mat index so that the columns are summed, as armadillo stores data in column format
         
         
             NodeList2(,2) <- NodeList.col(4)*tstep +0.5*NodeList.col(8)*tstep^2 + NodeList.col(2); //#Distance/elevation s1 = ut+0.5at^2+s0
    NodeList2(,4) = NodeList.col(4) + NodeList.col(8)*tstep; //#velocity v1 = v0 +at
    NodeList2(,6) = NodeList.col(1) + NodeList.col(3); //#static force 
    NodeList2(,5) = coef_drag*NodeList2.col(4); //#friction of an object in a viscous fluid under laminar flow
    NodeList2(,7) = NodeList2.col(6) - NodeList2.col(5); //#net force
    NodeList2(,8) = NodeList2.col(7)/mass; //#acceleration
    NodeList2(,9) = NodeList.col(9) + tstep; //#current time
}

NodeList = NodeList2

return Rcpp::List::create( Rcpp::Named("node_status") = NodeList,);
}')


Rcpp::cppFunction(depends = "RcppArmadillo", code = '
Rcpp::List flowCalcCpp(const arma::mat &Am, const arma::mat &Cm) {
   arma::mat B = inv(trans(Am) * Cm * Am);
   arma::mat PTDF = Cm * Am * B;
   return Rcpp::List::create( Rcpp::Named("Imp") = B ,
                           Rcpp::Named("PTDF") = PTDF );
}')


```


#Code for disucssion
```{r}
profvis(Find_network_balance(g = g,
                      force =force,
                      flow = flow,
                      distance = distance,
                       capacity = capacity,
                      edge_name = edge_name,
                      tstep = tstep,
                      tol = tol,
                      maxIter =1000 ,
                      mass = mass
))



profvis(Find_network_balance2(g = g,
                      force =force,
                      flow = flow,
                      distance = distance,
                      #  capacity = capacity,
                      edge_name = edge_name,
                      tstep = tstep,
                      tol = tol,
                      maxIter = 1000 ,
                      mass = mass
))

profvis(Find_network_balance3(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                               capacity = capacity,
                                               edge_name = edge_name,
                                               tstep = tstep,
                                               tol = tol,
                                               maxIter = 1000,
                                               mass = mass,
                                               verbose = FALSE))


profvis(Find_network_balance4(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                               capacity = capacity,
                                               edge_name = edge_name,
                                               tstep = tstep,
                                               tol = tol,
                                               max_iter = 1000,
                                               mass = mass,
                                               verbose = FALSE,
                                               sparse = FALSE,
                                               coef_drag =1.5))


profvis(Find_network_balance5(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                               capacity = capacity,
                                               edge_name = edge_name,
                                               tstep = tstep,
                                               tol = tol,
                                               max_iter = 1000,
                                               mass = mass,
                                               sparse = FALSE,
                                               coef_drag =1.5))



#This just shows that the relation is linear.
#This hardly seem like a contentious thing to say so is it necessary?
linear_proof <-{c(100, seq(from = 1,to = 31, by = 3)*1000)} %>% map_df(~{
  print(.x)
  temp <- system.time(Find_network_balance5(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                               capacity = capacity,
                                               edge_name = edge_name,
                                               tstep = tstep,
                                               tol = 0,
                                               max_iter = .x,
                                               mass = mass,
                                               sparse = FALSE,
                                               coef_drag =1.5))
  
  return(tibble(user = temp[[1]],
                            elapsed = temp[[3]],
                Iterations = .x))
  
})


linear_proof %>%
  ggplot(aes(x = Iterations, y = elapsed)) + geom_point() +
  labs(title = "The relationship between number of iterations and elapsed time on IEEE-118")



system.time(Find_network_balance(g = g,
                      force =force,
                      flow = flow,
                      distance = distance,
                       capacity = capacity,
                      edge_name = edge_name,
                      tstep = tstep,
                      tol = tol,
                      maxIter =2000 ,
                      mass = mass
))

 system.time(Find_network_balance5(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                               capacity = capacity,
                                               edge_name = edge_name,
                                               tstep = tstep,
                                               tol = 0,
                                               max_iter = 2000,
                                               mass = mass,
                                               sparse = FALSE,
                                               coef_drag =1.5))
 
 
 linear_proof_original <-{c(100, seq(from = 1,to = 31, by = 3)*1000)} %>% map_df(~{
  print(.x)
  temp <- system.time(Find_network_balance(g = g,
                      force =force,
                      flow = flow,
                      distance = distance,
                       capacity = capacity,
                      edge_name = edge_name,
                      tstep = tstep,
                      tol = tol,
                      maxIter =.x,
                      mass = mass
))
  
  return(tibble(user = temp[[1]],
                            elapsed = temp[[3]],
                Iterations = .x))
  
})

 bind_rows(#linear_proof %>% mutate(type = "final"),
           linear_proof_original %>% mutate(type = "original")
           ) %>%
  ggplot(aes(x = Iterations, y = (user), colour = type)) + geom_point() +
  labs(title = "The relationship between number of iterations and elapsed time on IEEE-118")
 
 
test <-  microbenchmark(final = Find_network_balance5(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                               capacity = capacity,
                                               edge_name = edge_name,
                                               tstep = tstep,
                                               tol = 0,
                                               max_iter = .x,
                                               mass = mass,
                                               sparse = FALSE,
                                               coef_drag =1.5),
                        unit = "ms",
                        times = 20) %>%
  summary() %>%
  mutate(Iterations = .x)


```

#microbench approach
```{r}

start.time <- Sys.time()
linear_proof_micro <-{c(100, seq(from = 1,to = 31, by = 3)*1000)} %>% map_df(~{
  print(.x)
  temp <-  microbenchmark(final = Find_network_balance5(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                               capacity = capacity,
                                               edge_name = edge_name,
                                               tstep = tstep,
                                               tol = 0,
                                               max_iter = .x,
                                               mass = mass,
                                               sparse = FALSE,
                                               coef_drag =1.5),
                        unit = "ms",
                        times = 20) %>%
  summary() %>%
  mutate(Iterations = .x)
  
  return(temp)
  
})
stop.time <- Sys.time()

stop.time-start.time

linear_proof_micro %>%
  pivot_longer(cols = c(lq, uq, mean, max, min)) %>%
  mutate(type = case_when(
    name =="lq" | name == "uq" ~ "quartile limit",
    name =="min" | name =="max" ~ "extrema",
    name == "mean" ~"mean",
  )) %>%
  ggplot(aes(x = Iterations, y = (value), colour = type, group = name)) + geom_line() +
  labs(title = "The relationship between number of iterations and elapsed time on IEEE-118")


linear_proof_micro %>%
  ggplot(aes(x = Iterations, y = mean)) +
  geom_ribbon(aes(ymin = min, ymax = max),  fill = "blue", alpha = 0.25) +
  geom_ribbon(aes(ymin = lq, ymax = uq), fill = "red", alpha = 0.25)+
  geom_line() +
  #scale_y_log10()+
  labs(title = "The relationship between number of iterations and elapsed time on IEEE-118")



 microbenchmark(v4 = Find_network_balance4(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                               capacity = capacity,
                                               edge_name = edge_name,
                                               tstep = tstep,
                                               tol = 0,
                                               max_iter = .x,
                                               mass = mass,
                                               sparse = FALSE,
                                               coef_drag =1.5),
                v5 = Find_network_balance5(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                               capacity = capacity,
                                               edge_name = edge_name,
                                               tstep = tstep,
                                               tol = 0,
                                               max_iter = .x,
                                               mass = mass,
                                               sparse = FALSE,
                                               coef_drag =1.5),
                        unit = "ms",
                        times = 20) 
 
 
 
 system.time(Find_network_balance5(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                               capacity = capacity,
                                               edge_name = edge_name,
                                               tstep = tstep,
                                               tol = 0,
                                               max_iter = 1000,
                                               mass = mass,
                                               sparse = FALSE,
                                               coef_drag =1.5))
 
 
 #Times taken from profvis for 1000 reps
 tibble(version =c(1:5), time =48530/rev(c(370, 1530, 1950, 6100, 48530)), rel_change = time/lag(time)) %>%
   ggplot(aes(x = version, y =rel_change)) + geom_col() +
   labs(title = "Speed-up on previous version of SETSe", y = "relative change")

  tibble(version =c(1:5), time =48530/rev(c(370, 1530, 1950, 6100, 48530)), rel_change = time/lag(time)) %>%
   ggplot(aes(x = version, y = time)) + geom_col() +
   labs(title = "Speed-up from original SETSe algorithm", y = "relative change")

   tibble(version =c(1:5), time =48530/rev(c(370, 1530, 1950, 6100, 48530)), rel_change = time/lag(time)) %>%
     pivot_longer(cols = c("time", "rel_change")) %>%
     mutate(value =ifelse(is.na(value),1, value),
            name = ifelse(name=="time", "Time", "Relative change")) %>%
     ggplot(aes(x = version, y = value)) + geom_col()+
     facet_wrap(~name, scales = "free_y") +
   labs(title = "Speed-up from original SETSe algorithm", y = "relative speed-up")
 
```


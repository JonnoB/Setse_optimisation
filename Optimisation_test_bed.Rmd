---
title: "Optimise sets-e"
author: "Jonathan Bourne"
date: "24/12/2019"
output: html_document
editor_options: 
  chunk_output_type: console
---

Sets-e can be pretty slow. and due to the large amount of iterations it goes through this adds up

What can I do the get speed up improvements?

#setup
Load data. I am going to use provis so I can't load the package version of the function I have to load them direct into the workspace
```{r}
packages <- c("tidyverse", "igraph", "igraphdata", "minpack.lm", "ggraph", "profvis", "microbenchmark")

new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
sapply(packages, library, character.only = TRUE)

list.files(file.path("/home/jonno/Useful_PhD__R_Functions"), pattern = ".R", full.names = T) %>%
  walk(~source(.x))

list.files(file.path("/home/jonno/NetworkSpringEmbedding/R"), pattern = ".R", full.names = T) %>%
  walk(~source(.x))

list.files(file.path("/home/jonno/Setse_optimisation/Alterantive_functions"), pattern = ".R", full.names = T) %>%
  walk(~source(.x))

library(PowerGridNetworking)
```


I will use the zachery karate club as an example dataset
```{r}
data("karate", package="igraphdata")

shortest_list <-shortest_paths(karate, from = 1, to = 34, mode = "all" , weights = get.edge.attribute(karate, "weight"), output = "both")

flow_df <- subgraph.edges(karate, shortest_list$epath[[1]]) %>% as_data_frame() %>% 
  mutate(routes = 1) %>% #trying to think how this can be generalised
  group_by(from, to) %>%
  summarise(routes = sum(routes))

karate_edge_df <- as_data_frame(karate) %>%
  mutate(temporary_flow = 1) %>%
  left_join(flow_df) %>%
  mutate(routes = ifelse(is.na(routes), 0, routes),
         edge_name = paste(from, to, sep = "_"))
karate_node_df <- as_data_frame(karate, what = "vertices") %>%
  select(name, everything()) %>%
  mutate(force = case_when(
    name =="Mr Hi" ~1,
    name == "John A" ~-1,
    TRUE ~0
  ))

g <- graph_from_data_frame(karate_edge_df, directed = FALSE, vertices = karate_node_df)  %>%
        set.edge.attribute(. , "distance", value = 1) %>%
        set.edge.attribute(., "Area", value = 1) %>%
        calc_spring_youngs_modulus(., "temporary_flow", "weight", minimum_value = 100, stretch_range = 1000) %>%
        calc_spring_constant(., E ="E", A = "Area", distance = "distance") 

```

#IEEE graph set
```{r}

g2 <- readRDS(file.path("/home/jonno/Dropbox/IEEE_Networks/power_grid_graphs", "IEEE_300_igraph.rds" ))

g3 <- g2 %>% Proportional_Load(., 2, PowerFlow = "power_flow", Link.Limit = "edge_capacity")

      current_graph  <- g3 %>%
        set.edge.attribute(. , "distance", value = 1) %>%
        set.edge.attribute(., "Area", value = 1) %>%
        calc_spring_youngs_modulus(., "power_flow", "edge_capacity", minimum_value = 100, stretch_range = 1000) %>%
        calc_spring_constant(., E ="E", A = "Area", distance = "distance") %>%
        normalise_dc_load(.,  
                           generation = "generation", 
                           demand  = "demand",
                           net_generation = "net_generation", 
                           capacity = "edge_capacity",
                           edge_name = "edge_name", 
                           node_name = "name",
                           power_flow = "power_flow")
      g <- current_graph
      
            List_of_BiConComps <- create_balanced_blocks(current_graph, 
                                                   force = "net_generation", 
                                                   flow = "power_flow")
      
      #find the largest component and use that as the origin block
      giant_componant <-List_of_BiConComps %>% map_dbl(~vcount(.x)) %>% which.max()
      
      print("Giant component found")
      
      #use the largest block to set the simulation parameters k and m.
      #k needs to be sufficiently stretched to allow enough topology variation. otherwise all that happens is a 
      #surface angled in the direct of net power flow. Which is interesting but not that interesting
      OriginBlock_complete <- Find_network_balance2(g = current_graph,
                                                   force ="net_generation",
                                                   flow = "power_flow",
                                                   distance = "distance",
                                                   capacity = "edge_capacity",
                                                   edge_name = "edge_name",
                                                   tstep = tstep/10,
                                                   tol = tol,
                                                   maxIter = maxIter*10,
                                                   mass = mass,
                                                   verbose = FALSE)
      
      test <- OriginBlock_complete$results
      test2 <- OriginBlock_complete$NodeList


      plot(test)
```

#profile function
```{r}


force = "force"
              flow = "routes" 
              distance = "distance" 
              capacity = "weight"
              edge_name = "edge_name"
              k = "k"
              tstep = 0.02
              tol = 10e-14
              maxIter = 1000
              mass = 1
              verbose = FALSE

#going inside the Find_network_balance function

 Prep <- Prepare_data_for_find_network_balance(g, force, flow, distance, mass, edge_name)
 
 Prep <- Prepare_data_for_find_network_balance2(g, force, flow, distance, mass, edge_name)  

 NodeStatus <- Prep$NodeStatus
 Link <- Prep$Link
 Adjmat <- Prep$Adjmat
 kmat <- Prep$kmat
 dmat <- Prep$dmat
frctmultiplier <-1

time_test_orig_start <- system.time( test_original_algos<-  Find_network_balance(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                               capacity = capacity,
                                               edge_name = edge_name,
                                               tstep = tstep,
                                               tol = tol,
                                               maxIter = 4e4,
                                               mass = mass,
                                               verbose = FALSE))
 test_original_algos <-  Find_network_balance(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                               capacity = capacity,
                                               edge_name = edge_name,
                                               tstep = tstep,
                                               tol = tol,
                                               maxIter = maxIter,
                                               mass = mass,
                                               verbose = FALSE)

 time_test_new_start <- system.time(  test_new_algos<-  Find_network_balance2(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                               capacity = capacity,
                                               edge_name = edge_name,
                                               tstep = tstep,
                                               tol = tol,
                                               maxIter = 4e4,
                                               mass = mass,
                                               verbose = FALSE))
 
  test_new_algos_1 <-  Find_network_balance2(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                               capacity = capacity,
                                               edge_name = edge_name,
                                               tstep = tstep,
                                               tol = tol,
                                               maxIter = maxIter,
                                               mass = mass,
                                               verbose = FALSE)
  
    test_new_algos_2 <-  Find_network_balance3(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                               capacity = capacity,
                                               edge_name = edge_name,
                                               tstep = tstep,
                                               tol = tol,
                                               maxIter = maxIter,
                                               mass = mass,
                                               verbose = FALSE)
  
    
    profvis(Find_network_balance(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                               capacity = capacity,
                                               edge_name = edge_name,
                                               tstep = tstep,
                                               tol = tol,
                                               maxIter = 1000,
                                               mass = mass,
                                               verbose = FALSE))
    
    profvis(Find_network_balance3(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                               capacity = capacity,
                                               edge_name = edge_name,
                                               tstep = tstep,
                                               tol = tol,
                                               maxIter = 1000,
                                               mass = mass,
                                               verbose = FALSE),
            interval = 0.005)
    
  all_equal(test_original_algos$NodeList, test_new_algos_1$NodeList)
  all_equal(test_new_algos_1$NodeList, test_new_algos_2$NodeList)
    
  new_NodeList <- test_new_algos$NodeList
  original_NodeList <- test_original_algos$NodeList
  
  test <- test_original_algos$results
  test2 <- test_new_algos$results
all_equal(test, test2)
  

#The results file for the original and new algos are different on max absolute acceleration. I don't know why
#everything else is the same

bind_rows(test_new_algos$results %>% mutate(type = "new"), 
          test_original_algos$results %>% mutate(type = "original")) %>% as_tibble() %>%
#  filter(t<20) %>%
  ggplot(aes(x = t, y = acceleration, colour = type)) + geom_line()

40*31000/60/24/30

(5/6)*31000/60/24


x <- data.frame(matrix(runif(100 * 1e4), ncol = 100))
medians <- vapply(x, median, numeric(1))

for(i in seq_along(medians)) {
  x[, i] <- x[, i] - medians[i]
}

for(i in 1:5) {
  x[, i] <- x[, i] - medians[i]
  print(c(address(x), refs(x)))
}

```


The majority of time is spent in Calc_System_dynamis

```{r}
 profvis(Calc_System_Dynamics(Prep$NodeStatus, Prep$A,  Prep$Link$k, pull(Prep$Link,distance), tstep, 1))


 profvis(microbenchmark(Calc_System_Dynamics(Prep$NodeStatus, Prep$A,  Prep$Link$k, pull(Prep$Link,distance), tstep, 1)), interval = 0.005)

NodeStatus <- Prep$NodeStatus
NodeStatus2 <- Prep$NodeStatus %>% mutate(Delta_acceleration = 0)
kvect <- Prep$Link$k
dvect <- pull(Prep$Link,distance)
EdgeNode <- Prep$A


 microbenchmark(A = Create_Tension_matrix(Prep$A, NodeStatus$z, kvect, dvect),
                B = Calc_Damping_matrix(Prep$A, NodeStatus$velocity, kvect, NodeStatus$mass))
```


#test the time step
```{r}



tstep_test <- {seq(0.017, 0.02, by = 0.001  )} %>% #0.02%>%# 
  map_df(~{
    print(.x)
   res <- Find_network_balance2(g = g,
                                               force =force,
                                               flow = flow,
                                               distance = distance,
                                               capacity = capacity,
                                               edge_name = edge_name,
                                               tstep = .x,
                                               tol = tol,
                                               maxIter = 10000,
                                               mass = mass,
                                               verbose = FALSE)
    
 Out <-  res$results %>% mutate(tstep = .x)
 return(Out) 
 }) %>%
  group_by(tstep) %>%
  mutate(t_norm = t/max(t, na.rm = T)) %>%
  ungroup %>%
  filter(complete.cases(.))

tstep_test %>%
#filter(tstep <0.02) %>%
 # filter(t_norm>0.75, t_norm<0.80) %>%
ggplot(aes(x = t_norm, y =net_force+ kinetic_force, colour = as.factor(tstep))) + geom_line()


tstep_test %>%
#filter(tstep <0.02) %>%
ggplot(aes(x = log10(net_force), y = log10(kinetic_force), colour = as.factor(tstep))) + geom_point()


test <- tstep_test %>%
  filter(tstep == 0.02)
```

